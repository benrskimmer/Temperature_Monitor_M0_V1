/*
 * screen_msg_buffer.c
 *
 * Created: 1/19/2022 9:54:15 PM
 *  Author: Ben
 */ 

/*
Theory of operation:
We allocate an array of screen message structs. These structs contain info about if the given struct is being used. Calling
get_free_msg fetches the first unused message struct in the array. Upon creating a new message, space is allocated via malloc
to save the string we want to display, and freed upon deleting a message.

Message order is controlled by means of a doubly linked list where each struct in the array has pointers to the previous and
next message to be displayed. The refresh_screen_msg function iterates through the message by following this doubly linked
list, not iterating through the array. Messages are inserted into the linked list based on two factors, priority and origin.
1-time use messages generated by print_msg are inserted right after the current msg, even interrupting it. Normal messages are
inserted based on their relative priority. Messages are popped from the queue when their repeat counter expires.

Variable rules:
if current_disp_msg is NULL, all priority queues are empty
message_queues is a list of heads of queues. Each index representing a different priority
*/


#include "screen_msg_buffer.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

scrn_msg_t message_buf[MAX_MSGS];
scrn_msg_t* message_queues[LOWEST_MSG_PRIORITY + 1]; // each index is the node of a message priority queue
scrn_msg_t* current_disp_msg = message_buf;

bool split_screen = false; // set this to fix sensor data and stats to top of screen

//int8_t start_message_idx = -1;



// ------- Private Function Prototypes -------
uint8_t space_available(void);
scrn_msg_t* get_free_msg(void);
void insert_queue_priority(scrn_msg_t* msg);
void insert_queue_next(scrn_msg_t* msg);
void pop_queue_msg(scrn_msg_t* msg);
scrn_msg_t* get_next_disp_msg(void);
void disp_next_message(void);


// ------- Private Functions -------

uint8_t space_available(void)
{
	uint8_t count = 0;
	for(int i = 0; i < MAX_MSGS; i++)
	{
		if(message_buf[i].used == false) count++;
	}
	return count;
}

// get the first unused message
scrn_msg_t* get_free_msg(void)
{
	scrn_msg_t* msg = NULL;
	
	for(int i = 0; i < MAX_MSGS; i++)
	{
		if(message_buf[i].used == false)
		{
			msg = &message_buf[i];
			break;
		}
	}
	assert(msg != NULL);
	
	return msg;
}

// appends msg to the end of a priority queue
void append_queue(scrn_msg_t* msg)
{
	if(message_queues[msg->priority] == NULL) // if this priority queue is empty
	{
		message_queues[msg->priority] = msg; // append as head of this priority queue
		msg->previous = NULL;
		msg->next = NULL;
	}
	else
	{
		scrn_msg_t* last_msg = message_queues[msg->priority];
		while(last_msg->next != NULL) last_msg = last_msg->next;
		last_msg->next = msg;
		msg->previous = last_msg;
		msg->next = NULL;
	}
}

// this should only be used with messages with a cycle count of 1
void insert_queue_next(scrn_msg_t* msg)
{
	// if there's no messages displayed, append this message based on it's default priority
	if(current_disp_msg == NULL)
	{
		append_queue(msg);
// 		message_queues[msg->priority] = msg; // this is now the head message
// 		current_disp_msg = msg; // display it now
// 		msg->previous = NULL;
// 		msg->next = NULL;
	}
	else
	{
		msg->next = current_disp_msg->next;
		current_disp_msg->next = msg;
		msg->previous = current_disp_msg;
		if(msg->next != NULL)
			msg->next->previous = msg;
		msg->priority=current_disp_msg->priority; // update the message priority to the level of the priority queue we're adding it to
	}
}

void pop_queue_msg(scrn_msg_t* msg)
{
	if(message_queues[msg->priority] == msg) // if this is the head of a priority queue, update the head pointer
		message_queues[msg->priority] = msg->next;
		
	// splice queue if removing from the middle of a queue
	if(msg->previous != NULL)
		msg->previous->next = msg->next;
	if(msg->next != NULL)
		msg->next->previous = msg->previous;
	
	// clean up unused struct
	msg->next = NULL;
	msg->previous = NULL;
}

// used by the update screen function to get the next message to display
scrn_msg_t* get_next_disp_msg(void)
{
	if(current_disp_msg == NULL) // if the current display message is NULL, check if any of the priority queues have a message
	{
		for(int i = 0; i <= LOWEST_MSG_PRIORITY; i++)
		{
			if(message_queues[i] != NULL)
				return message_queues[i];
		}
		return NULL;
	}
	
	if(current_disp_msg->next != NULL)
		return current_disp_msg->next;
	
	for(int i = 0; i <= LOWEST_MSG_PRIORITY; i++) // jump to the next priority queue
	{
		uint8_t priority_queue = (current_disp_msg->priority + i) % LOWEST_MSG_PRIORITY;
		if(message_queues[priority_queue] != NULL)
			return message_queues[priority_queue];
	}
	
	return NULL;
}

// display the next message
void disp_next_message(void)
{
	current_disp_msg = get_next_disp_msg();
	
	// push message to screen...
	
	
	
}



// ------- Public Functions -------

// configures a new (free) message and returns a handle to it with default configurations
// this allows the application to hold onto and dynamically configure/update the message
// use print_message to print 1-time messages
scrn_msg_t* new_message(char* msg_str, uint8_t priority)
{
	assert(msg_str);
	size_t len = strlen(msg_str);
	assert(msg_str <= MAX_MSG_LEN);
	assert(priority <= LOWEST_MSG_PRIORITY);
	
	scrn_msg_t* msg = get_free_msg();
	
	msg->used = true;
	msg->active = true;
	msg->cycles_left = -1;
	msg->display_time = 3; // TODO, determine this on message length
	msg->priority = priority;
	msg->message = malloc(len);
	
	assert(msg->message != NULL);
	
	strlcpy(msg->message, msg_str, len);
	
	append_queue(msg);
	
	return msg;
}


void delete_message(scrn_msg_t* msg)
{
	if(msg == NULL) return;
	
	if(current_disp_msg == msg) // if this message is currently being displayed, display the next message
		disp_next_message();
	
	pop_queue_msg(msg);
	
	msg->used = false;
	
	free(msg->message);
}


// gets a free message and configures it to display the given text once and then frees the message
// intended for time-sensitive 1-time messages (debug etc)
void print_message(char* msg_str)
{
	size_t len = strlen(msg_str);
	assert(msg_str <= MAX_MSG_LEN);
	
	scrn_msg_t* msg = get_free_msg();
	
	msg->used = true;
	msg->active = true;
	msg->cycles_left = 1;
	msg->display_time = 3;
	msg->priority = LOWEST_MSG_PRIORITY; // default to lowest, doesn't really matter given we're inserting it next
	msg->message = malloc(len);
	
	assert(msg->message != NULL);
	
	strlcpy(msg->message, msg_str, len);
	
	insert_queue_next(msg);
	
	if(current_disp_msg->cycles_left == -1) // if the current message is infinite, skip it and refresh the screen
		disp_next_message();
}


void print_message_repeat(char* msg_str, uint8_t repeat_cycles, uint8_t priority)
{
	size_t len = strlen(msg_str);
	assert(msg_str <= MAX_MSG_LEN);
	
	scrn_msg_t* msg = get_free_msg();
	
	msg->used = true;
	msg->active = true;
	msg->cycles_left = (int8_t)repeat_cycles;
	msg->display_time = 3;
	msg->priority = priority;
	msg->message = malloc(len);
	
	assert(msg->message != NULL);
	
	strlcpy(msg->message, msg_str, len);
	
	append_queue(msg);
}
	

void update_priority(scrn_msg_t* msg, uint8_t priority)
{
	assert(priority <= LOWEST_MSG_PRIORITY);
	
	// remove from existing priority queue and append to new priority queue
	pop_queue_msg(msg);
	msg->priority = priority;
	append_queue(msg);
}


void update_repeat(scrn_msg_t* msg, uint8_t repeats)
{
	msg->cycles_left = repeats;
}

//void set_first(scrn_msg_t* msg);

void refresh_screen_msg(void);